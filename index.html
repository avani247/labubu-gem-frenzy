<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Labubuâ€™s Gem Frenzy</title>
<style>
  /* Fixed-size canvas; no responsive scaling */
  html, body { margin:0; padding:0; background:#0a0a1a; overflow:hidden; }
  canvas { display:block; margin:0 auto; background:#10102a; width:480px; height:640px; }
</style>
</head>
<body>
<canvas id="game" width="480" height="640"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = 480, H = 640;

  // ---------- Tuning ----------
  const SCROLL_SPEED = 3;     // Flappy-ish
  const GRAV = 0.15;
  const JUMP = -4;
  const WIN_SCORE = 1000;     // optional win condition

  // ---------- Assets ----------
  const ASSETS = {
    labubu: 'astronaut labubu.png',
    gems: ['blue gemstone.png','green gemstone.png','red gemstone.png'],
    // Replace fire monster with stone; keep monster obstacle
    obstacles: ['stone.png','monster obstacle.png']
  };
  const imgs = { labubu:null, gem:[], obs:[] };
  let loaded = 0, total = 1 + ASSETS.gems.length + ASSETS.obstacles.length;

  function loadImage(target, src, i) {
    const img = new Image();
    img.onload = () => { loaded++; };
    img.onerror = () => { loaded++; };
    img.src = src;
    if (target === 'labubu') imgs.labubu = img;
    else if (target === 'gem') imgs.gem[i] = img;
    else if (target === 'obs') imgs.obs[i] = img;
  }
  loadImage('labubu', ASSETS.labubu);
  ASSETS.gems.forEach((g,i)=>loadImage('gem', g, i));
  ASSETS.obstacles.forEach((o,i)=>loadImage('obs', o, i));

  // ---------- Sounds ----------
  const sounds = {
    collect: new Audio('Collect gemstone sound.mp3'),
    gameover: new Audio('game over sound.mp3'),
    winner: new Audio('winner sound.mp3')
  };
  // Preload and sensible volumes
  Object.values(sounds).forEach(a => { a.preload = 'auto'; a.volume = 0.9; });
  let audioUnlocked = false;
  function unlockAudio() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    // Nudge each audio once so the browser flags it as user-initiated
    Object.values(sounds).forEach(a => {
      try {
        a.muted = true;
        a.currentTime = 0;
        a.play().then(() => { a.pause(); a.currentTime = 0; a.muted = false; })
                 .catch(() => { a.muted = false; });
      } catch(e) {}
    });
  }

  // ---------- Background ----------
  const bgGrad = ctx.createLinearGradient(0,0,0,H);
  bgGrad.addColorStop(0,'#1e1f4f'); bgGrad.addColorStop(1,'#0a0a1a');

  class Star {
    constructor(x,y,s,spd){ this.x=x; this.y=y; this.s=s; this.spd=spd; }
    update(){ this.x -= this.spd; if(this.x<0) this.x=W; }
    draw(){ ctx.fillStyle='#8a8ab7'; ctx.fillRect(this.x,this.y,this.s,this.s); }
  }
  const stars=[[],[],[]];
  [0.2,0.5,1.0].forEach(spd=>{ for(let j=0;j<50;j++) stars[0].push(new Star(Math.random()*W,Math.random()*H,Math.random()*2+1,0.2)); });
  [0.2,0.5,1.0].forEach(spd=>{ for(let j=0;j<50;j++) stars[1].push(new Star(Math.random()*W,Math.random()*H,Math.random()*2+1,0.5)); });
  [0.2,0.5,1.0].forEach(spd=>{ for(let j=0;j<50;j++) stars[2].push(new Star(Math.random()*W,Math.random()*H,Math.random()*2+1,1.0)); });

  // ---------- Persistence ----------
  const NAMES_KEY='players';             // most-recent first
  const BEST_BY_NAME_KEY='bestByName';   // { name: best }
  const GLOBAL_BEST_KEY='bestScore';     // number

  const loadJSON = (k, d) => { try { return JSON.parse(localStorage.getItem(k) ?? JSON.stringify(d)); } catch(e){ return d; } };
  const saveJSON = (k, v) => localStorage.setItem(k, JSON.stringify(v));

  let names = loadJSON(NAMES_KEY, []);
  let bestByName = loadJSON(BEST_BY_NAME_KEY, {});
  let globalBest = parseInt(localStorage.getItem(GLOBAL_BEST_KEY) || '0', 10);

  // Recompute global best ONLY from per-player bests (clears stale values)
  (() => {
    const vals = Object.values(bestByName || {});
    const computed = vals.length ? Math.max(...vals) : 0;
    if (computed !== globalBest) {
      globalBest = computed;
      localStorage.setItem(GLOBAL_BEST_KEY, String(globalBest));
    }
  })();

  // ---------- State ----------
  const STATE = { NAME:0, TYPE:1, PLAY:2, OVER:3 };
  let state = names.length ? STATE.NAME : STATE.TYPE;

  let currentName = null;
  let typedName = '';

  let frame=0, score=0, won=false, newGlobalHigh=false;
  const labubu = { x: W/3, y: H/2, r: 43, yVel: 0 };
  const dusts=[], gems=[], obstacles=[];
  let confetti=[];

  // ---------- Spawns ----------
  function spawnDust() {
    if (frame % 10 === 0) dusts.push({
      x: W, y: Math.random()*H, r: Math.random()*2+1,
      dx: Math.random()*0.5+0.2, dy: Math.random()*0.2-0.1, a: Math.random()*0.5+0.2
    });
  }
  function spawnEntities() {
    const diff = 1 + Math.floor(score/7)*0.1;
    const gi = Math.floor(Math.random()*imgs.gem.length);
    gems.push({img: imgs.gem[gi], x: W+50, y: 50+Math.random()*(H-100), size: 48});
    const count = 1 + Math.floor(diff);
    for (let i=0;i<count;i++) {
      const oi = Math.floor(Math.random()*imgs.obs.length);
      obstacles.push({img: imgs.obs[oi], x: W+100+i*80, y: Math.random()*(H-60)+30, size: 58});
    }
  }

  // ---------- Confetti ----------
  function initConfetti(){
    confetti.length=0;
    for(let i=0;i<120;i++){
      confetti.push({
        x: W/2, y: H/2,
        dx: (Math.random()*4-2),
        dy: (Math.random()*-4-1),
        c: `hsl(${Math.random()*360},80%,60%)`
      });
    }
  }
  function updateConfetti(){ confetti.forEach(p=>{ p.x+=p.dx; p.y+=p.dy; p.dy+=0.05; }); }
  function drawConfetti(){ confetti.forEach(p=>{ ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,4,8); }); }

  // ---------- Helpers ----------
  function toGameXY(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    return { x: (clientX - r.left) * (W / r.width),
             y: (clientY - r.top)  * (H / r.height) };
  }

  function setName(name){
    currentName = (name || 'Player').trim().slice(0,16) || 'Player';
    names = [currentName, ...names.filter(n=>n!==currentName)].slice(0,10);
    saveJSON(NAMES_KEY, names);
    if(!(currentName in bestByName)) { bestByName[currentName]=0; saveJSON(BEST_BY_NAME_KEY, bestByName); }
    startRun();
  }

  function startRun(){
    frame=0; score=0; won=false; newGlobalHigh=false;
    labubu.y = H/2; labubu.yVel = 0;
    gems.length=0; obstacles.length=0; dusts.length=0; confetti.length=0;
    state = STATE.PLAY;
  }

  function endRun(byCollision=true){
    state = STATE.OVER;
    won = score >= WIN_SCORE;

    // per-player
    if(currentName){
      if(score > (bestByName[currentName]||0)){
        bestByName[currentName] = score;
        saveJSON(BEST_BY_NAME_KEY, bestByName);
      }
    }

    // play game over sound right away
    if (byCollision) {
      try { sounds.gameover.currentTime = 0; sounds.gameover.play(); } catch(e) {}
    }

    // global best check
    if(score > globalBest){
      globalBest = score;
      localStorage.setItem(GLOBAL_BEST_KEY, String(globalBest));
      newGlobalHigh = true;
      initConfetti();
      // celebrate shortly after game-over thud
      setTimeout(() => { try { sounds.winner.currentTime = 0; sounds.winner.play(); } catch(e) {} }, 150);
    }
  }

  // ---------- Input ----------
  function flap(){
    unlockAudio();
    if(state === STATE.PLAY) labubu.yVel = JUMP;
    else if(state === STATE.OVER) startRun();
  }
  canvas.addEventListener('mousedown', e=>{
    unlockAudio();
    const {x,y} = toGameXY(e.clientX, e.clientY);
    if(state === STATE.NAME){
      const opts = recentNameButtons();
      for(const b of opts){ if(x>b.x && x<b.x+b.w && y>b.y && y<b.y+b.h){
        if(b.type==='pick') setName(b.value);
        else if(b.type==='type') { typedName=''; state=STATE.TYPE; }
      }}
    } else if(state === STATE.TYPE){
      const {ok} = typeUI();
      if(x>ok.x && x<ok.x+ok.w && y>ok.y && y<ok.y+ok.h){ setName(typedName); }
    } else if(state === STATE.OVER){
      const b = playAgainButton();
      if(x>b.x && x<b.x+b.w && y>b.y && y<b.y+b.h) startRun();
    } else {
      flap();
    }
  });
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); unlockAudio(); const t=e.changedTouches[0]; canvas.dispatchEvent(new MouseEvent('mousedown',{clientX:t.clientX, clientY:t.clientY})); });
  document.addEventListener('keydown', e=>{
    unlockAudio();
    if(state === STATE.TYPE){
      if(e.key === 'Enter'){ setName(typedName); return; }
      if(e.key === 'Backspace'){ typedName = typedName.slice(0,-1); return; }
      if(e.key.length === 1 && typedName.length < 16){
        if(/[A-Za-z0-9 _-]/.test(e.key)) typedName += e.key;
      }
      return;
    }
    if(e.code === 'Space' || e.key === ' ' || e.key === 'ArrowUp') { e.preventDefault(); flap(); }
    if(e.key === 'r' || e.key === 'R'){ if(state===STATE.PLAY || state===STATE.OVER) startRun(); }
  });

  // ---------- Update ----------
  function update(){
    if(loaded < total) return;
    if(state !== STATE.PLAY) { if(newGlobalHigh) updateConfetti(); return; }

    frame++;

    // physics
    labubu.yVel += GRAV;
    labubu.y += labubu.yVel;
    if(labubu.y - labubu.r < 0){ labubu.y = labubu.r; labubu.yVel = 0; }
    if(labubu.y + labubu.r > H){ labubu.y = H - labubu.r; labubu.yVel = 0; }

    // spawns
    const interval = Math.max(60, Math.round(100 / (1 + Math.floor(score/7)*0.1)));
    if(frame % interval === 0) spawnEntities();
    spawnDust();

    // move & collisions
    for(let i=gems.length-1;i>=0;i--){
      const g=gems[i]; g.x -= SCROLL_SPEED;
      if(g.x + g.size < 0) gems.splice(i,1);
      else if (Math.hypot(g.x-labubu.x, g.y-labubu.y) < labubu.r + g.size/2){
        score++; gems.splice(i,1);
        try { sounds.collect.currentTime = 0; sounds.collect.play(); } catch(e) {}
      }
    }
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i]; o.x -= SCROLL_SPEED;
      if(o.x + o.size < 0) obstacles.splice(i,1);
      else if (Math.hypot(o.x-labubu.x, o.y-labubu.y) < labubu.r + o.size/2){
        endRun(true);
      }
    }
    for(let i=dusts.length-1;i>=0;i--){
      const d=dusts[i]; d.x -= SCROLL_SPEED*0.5 + d.dx; d.y += d.dy;
      if(d.x < -d.r) dusts.splice(i,1);
    }
  }

  // ---------- UI helpers ----------
  function recentNameButtons(){
    const recent = names.slice(0,4);
    const btns = [];
    const bw=220, bh=36, gap=14;
    let y=200;
    if(recent.length){
      recent.forEach(n=>{
        btns.push({x:W/2-bw/2, y, w:bw, h:bh, type:'pick', value:n});
        y += bh + gap;
      });
      btns.push({x:W/2-bw/2, y:y+8, w:bw, h:bh, type:'type'});
    } else {
      btns.push({x:W/2-bw/2, y, w:bw, h:bh, type:'type'});
    }
    return btns;
  }
  function typeUI(){
    const fw=300, fh=40;
    const box = { x:W/2-fw/2, y:260, w:fw, h:fh };
    const ok  = { x:W/2-70, y:box.y+fh+14, w:140, h:36 };
    return {box, ok};
  }
  function playAgainButton(){
    const bw=160, bh=44;
    return { x: W/2 - bw/2, y: H/2 + 30, w:bw, h:bh };
  }

  // ---------- Draw ----------
  function draw(){
    ctx.fillStyle = bgGrad; ctx.fillRect(0,0,W,H);

    if(loaded < total){
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='24px sans-serif';
      ctx.fillText(`Loading ${loaded}/${total}`, W/2, H/2);
      return;
    }

    // stars
    stars.forEach(layer=>layer.forEach(s=>{ s.update(); s.draw(); }));

    // NAME screen
    if(state === STATE.NAME){
      ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center';
      ctx.font='28px sans-serif'; ctx.fillText("Who's playing?", W/2, 120);
      ctx.font='16px sans-serif'; ctx.fillText('Pick recent or type your name', W/2, 150);

      const btns = recentNameButtons();
      btns.forEach(b=>{
        ctx.fillStyle = (b.type==='type') ? '#444' : '#333';
        ctx.fillRect(b.x,b.y,b.w,b.h);
        ctx.strokeStyle='#777'; ctx.strokeRect(b.x,b.y,b.w,b.h);
        ctx.fillStyle='#fff'; ctx.font='18px sans-serif'; ctx.textAlign='center';
        ctx.fillText(b.type==='type' ? 'Type a new nameâ€¦' : b.value, b.x+b.w/2, b.y+24);
      });
      return;
    }

    // TYPE screen
    if(state === STATE.TYPE){
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center';
      ctx.font='28px sans-serif'; ctx.fillText('Type your name', W/2, 200);

      const {box, ok} = typeUI();
      ctx.fillStyle='#111'; ctx.fillRect(box.x,box.y,box.w,box.h);
      ctx.strokeStyle='#777'; ctx.strokeRect(box.x,box.y,box.w,box.h);
      ctx.fillStyle='#fff'; ctx.font='20px monospace'; ctx.textAlign='left';
      const shown = typedName || '';
      ctx.fillText(shown + (Math.floor(performance.now()/500)%2 ? '|' : ''), box.x+10, box.y+26);

      ctx.fillStyle='#444'; ctx.fillRect(ok.x,ok.y,ok.w,ok.h);
      ctx.strokeStyle='#777'; ctx.strokeRect(ok.x,ok.y,ok.w,ok.h);
      ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.textAlign='center';
      ctx.fillText('OK', ok.x+ok.w/2, ok.y+25);
      return;
    }

    // Game scene
    dusts.forEach(d=>{ ctx.fillStyle=`rgba(200,200,200,${d.a})`; ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,2*Math.PI); ctx.fill(); });
    gems.forEach(g=> ctx.drawImage(g.img, g.x-g.size/2, g.y-g.size/2, g.size, g.size));
    obstacles.forEach(o=> ctx.drawImage(o.img, o.x-o.size/2, o.y-o.size/2, o.size, o.size));
    if(imgs.labubu) ctx.drawImage(imgs.labubu, labubu.x-labubu.r, labubu.y-labubu.r, labubu.r*2, labubu.r*2);

    // HUD
    if(state === STATE.PLAY){
      ctx.fillStyle='#fff'; ctx.textAlign='left'; ctx.font='16px sans-serif';
      if(currentName) ctx.fillText(`Player: ${currentName}`, 10, 22);
      ctx.fillText(`Gems: ${score}`, 10, 42);
      ctx.fillText(`High: ${globalBest}`, 10, 62);
    }

    // OVER overlay
    if(state === STATE.OVER){
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      if(newGlobalHigh) drawConfetti();
      ctx.fillStyle='#fff'; ctx.textAlign='center';
      ctx.font='30px sans-serif';
      if(newGlobalHigh) ctx.fillText('You set a new highscore!', W/2, H/2 - 60);
      else ctx.fillText(won ? 'You Win!' : 'Game Over', W/2, H/2 - 60);
      ctx.font='20px sans-serif';
      ctx.fillText(`Your Score: ${score}`, W/2, H/2 - 20);
      ctx.fillText(`High Score: ${globalBest}`, W/2, H/2 + 8);

      const b = playAgainButton();
      ctx.fillStyle='#444'; ctx.fillRect(b.x,b.y,b.w,b.h);
      ctx.strokeStyle='#777'; ctx.strokeRect(b.x,b.y,b.w,b.h);
      ctx.fillStyle='#fff'; ctx.font='22px sans-serif';
      ctx.fillText('Play Again', W/2, b.y+30);
    }
  }

  // ---------- UI helpers ----------
  function recentNameButtons(){
    const recent = names.slice(0,4);
    const btns = [];
    const bw=220, bh=36, gap=14;
    let y=200;
    if(recent.length){
      recent.forEach(n=>{
        btns.push({x:W/2-bw/2, y, w:bw, h:bh, type:'pick', value:n});
        y += bh + gap;
      });
      btns.push({x:W/2-bw/2, y:y+8, w:bw, h:bh, type:'type'});
    } else {
      btns.push({x:W/2-bw/2, y, w:bw, h:bh, type:'type'});
    }
    return btns;
  }
  function typeUI(){
    const fw=300, fh=40;
    const box = { x:W/2-fw/2, y:260, w:fw, h:fh };
    const ok  = { x:W/2-70, y:box.y+fh+14, w:140, h:36 };
    return {box, ok};
  }
  function playAgainButton(){
    const bw=160, bh=44;
    return { x: W/2 - bw/2, y: H/2 + 30, w:bw, h:bh };
  }

  // ---------- Loop ----------
  function loop(){ update(); draw(); requestAnimationFrame(loop); }
  loop();
})();
</script>
</body>
</html>
