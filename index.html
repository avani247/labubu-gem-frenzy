<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Labubu’s Gem Frenzy</title>
<style>
  :root { --game-w:480px; --game-h:640px; }
  html, body {
    margin:0; height:100%; overflow:hidden; background:#0a0a1a;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  /* Center the game; canvas scales but internal resolution stays 480x640 */
  #wrap {
    position:relative; width:100vw; height:100vh;
    display:flex; align-items:center; justify-content:center;
    background: linear-gradient(to bottom, #1e1f4f, #0a0a1a);
  }
  canvas {
    display:block; width:var(--game-w); height:var(--game-h);
    /* smoothing for when we scale */
    image-rendering:auto;
  }
  /* Mobile name modal (real <input> so keyboard opens) */
  #nameModal {
    position:absolute; inset:0; display:none; place-content:center; z-index:5;
    background: rgba(0,0,0,0.5);
  }
  .card {
    min-width:280px; max-width:90vw;
    background:#111; color:#fff; padding:16px; border-radius:12px;
    box-shadow:0 10px 30px rgba(0,0,0,0.35);
  }
  .card h2 { margin:0 0 10px; font-size:20px; text-align:center; }
  .hint { color:#bbb; font-size:13px; text-align:center; margin-bottom:10px; }
  .row { display:flex; gap:8px; margin-top:8px; }
  .btn, .namebtn {
    border:1px solid #666; background:#333; color:#fff; border-radius:8px;
    padding:10px 14px; cursor:pointer;
  }
  .btn:active, .namebtn:active { transform: translateY(1px); }
  .namebtn { width:100%; text-align:center; }
  .input {
    flex:1; min-width:0; font-size:16px; padding:10px 12px;
    border-radius:8px; border:1px solid #666; background:#0c0c0c; color:#fff;
  }
  .list { display:grid; grid-template-columns:1fr; gap:8px; margin-top:10px; }
  @media (min-width:520px) { .list { grid-template-columns:1fr 1fr; } }
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="480" height="640" aria-label="Labubu’s Gem Frenzy"></canvas>

    <!-- Real HTML modal to trigger mobile keyboard -->
    <div id="nameModal" role="dialog" aria-modal="true">
      <div class="card">
        <h2>Who's playing?</h2>
        <div class="hint">Pick a recent name or type a new one.</div>
        <div id="recent" class="list"></div>
        <div class="row">
          <input id="nameInput" class="input" type="text" inputmode="text" maxlength="16"
                 autocomplete="nickname" placeholder="Type your name…" />
          <button id="startBtn" class="btn">Start</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = 480, H = 640;

  // ---------- Responsive fit (keeps logical 480×640, scales display) ----------
  function fitCanvas() {
    const scale = Math.min(window.innerWidth / W, window.innerHeight / H);
    const cssW = Math.max(1, Math.floor(W * scale));
    const cssH = Math.max(1, Math.floor(H * scale));
    canvas.style.width  = cssW + 'px';
    canvas.style.height = cssH + 'px';
  }
  window.addEventListener('resize', fitCanvas);
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', fitCanvas);
  }
  fitCanvas();

  // ---------- Tuning ----------
  const SCROLL_SPEED = 3;     // Flappy-ish
  const GRAV = 0.15;
  const JUMP = -4;
  const WIN_SCORE = 1000;

  // ---------- Assets ----------
  const ASSETS = {
    labubu: 'astronaut labubu.png',
    gems: ['blue gemstone.png','green gemstone.png','red gemstone.png'],
    obstacles: ['stone.png','monster obstacle.png'] // stone replaces fire
  };
  const imgs = { labubu:null, gem:[], obs:[] };
  let loaded = 0, total = 1 + ASSETS.gems.length + ASSETS.obstacles.length;

  function loadImage(target, src, i) {
    const img = new Image();
    img.onload = () => { loaded++; };
    img.onerror = () => { loaded++; }; // don't stall
    img.src = src;
    if (target === 'labubu') imgs.labubu = img;
    else if (target === 'gem') imgs.gem[i] = img;
    else if (target === 'obs') imgs.obs[i] = img;
  }
  loadImage('labubu', ASSETS.labubu);
  ASSETS.gems.forEach((g,i)=>loadImage('gem', g, i));
  ASSETS.obstacles.forEach((o,i)=>loadImage('obs', o, i));

  // ---------- Sounds ----------
  const sounds = {
    collect: new Audio('Collect gemstone sound.mp3'),
    gameover: new Audio('game over sound.mp3'),
    winner: new Audio('winner sound.mp3')
  };
  Object.values(sounds).forEach(a => { a.preload='auto'; a.volume=0.9; });
  let audioUnlocked = false;
  function unlockAudio() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    Object.values(sounds).forEach(a => {
      try {
        a.muted = true; a.currentTime = 0;
        const p = a.play();
        if (p && typeof p.then === 'function') {
          p.then(()=>{ a.pause(); a.currentTime=0; a.muted=false; })
           .catch(()=>{ a.muted=false; });
        } else { a.pause(); a.currentTime=0; a.muted=false; }
      } catch(e) { a.muted=false; }
    });
  }

  // ---------- Background ----------
  const bgGrad = ctx.createLinearGradient(0,0,0,H);
  bgGrad.addColorStop(0,'#1e1f4f'); bgGrad.addColorStop(1,'#0a0a1a');
  class Star { constructor(x,y,s,spd){this.x=x;this.y=y;this.s=s;this.spd=spd;}
    update(){ this.x-=this.spd; if(this.x<0) this.x=W; }
    draw(){ ctx.fillStyle='#8a8ab7'; ctx.fillRect(this.x,this.y,this.s,this.s); } }
  const stars=[[],[],[]];
  [0.2,0.5,1.0].forEach((spd,idx)=>{ for(let j=0;j<50;j++) stars[idx].push(new Star(Math.random()*W,Math.random()*H,Math.random()*2+1,spd)); });

  // ---------- Persistence ----------
  const NAMES_KEY='players', BEST_BY_NAME_KEY='bestByName', GLOBAL_BEST_KEY='bestScore';
  const loadJSON=(k,d)=>{try{return JSON.parse(localStorage.getItem(k)??JSON.stringify(d));}catch(e){return d;}};
  const saveJSON=(k,v)=>localStorage.setItem(k,JSON.stringify(v));
  let names=loadJSON(NAMES_KEY,[]), bestByName=loadJSON(BEST_BY_NAME_KEY,{});
  let globalBest=parseInt(localStorage.getItem(GLOBAL_BEST_KEY) || '0', 10);
  // Recompute global best only from per-player bests (clears stale values)
  (() => {
    const vals = Object.values(bestByName || {});
    const computed = vals.length ? Math.max(...vals) : 0;
    if (computed !== globalBest) {
      globalBest = computed;
      localStorage.setItem(GLOBAL_BEST_KEY, String(globalBest));
    }
  })();

  // ---------- State ----------
  const STATE = { NAME:0, PLAY:1, OVER:2 };
  let state = STATE.NAME;   // always show modal first (so keyboard can open)
  let currentName = null;

  let frame=0, score=0, won=false, newGlobalHigh=false;
  const labubu = { x: W/3, y: H/2, r: 43, yVel: 0 };
  const dusts=[], gems=[], obstacles=[];
  let confetti=[];

  // ---------- Name Modal (real input so mobile keyboard opens) ----------
  const modal = document.getElementById('nameModal');
  const nameInput = document.getElementById('nameInput');
  const startBtn = document.getElementById('startBtn');
  const recentWrap = document.getElementById('recent');

  function renderRecentNames() {
    recentWrap.innerHTML = '';
    const recent = names.slice(0,4);
    if (!recent.length) return;
    recent.forEach(n => {
      const b = document.createElement('button');
      b.className = 'namebtn';
      b.textContent = n;
      b.addEventListener('click', () => { setNameAndStart(n); });
      recentWrap.appendChild(b);
    });
  }
  function showNameModal() {
    modal.style.display = 'grid';
    renderRecentNames();
    // autofocus input (iOS sometimes needs a tiny delay)
    setTimeout(() => { nameInput.focus(); nameInput.select?.(); }, 50);
  }
  function hideNameModal() {
    modal.style.display = 'none';
  }
  function setNameAndStart(name) {
    currentName = (name || 'Player').trim().slice(0,16) || 'Player';
    names = [currentName, ...names.filter(n => n !== currentName)].slice(0,10);
    saveJSON(NAMES_KEY, names);
    if(!(currentName in bestByName)){ bestByName[currentName]=0; saveJSON(BEST_BY_NAME_KEY,bestByName); }
    startRun();
  }
  startBtn.addEventListener('click', () => setNameAndStart(nameInput.value));
  nameInput.addEventListener('keydown', e => { if(e.key==='Enter'){ e.preventDefault(); setNameAndStart(nameInput.value); } });

  // ---------- Spawns ----------
  function spawnDust(){ if(frame%10===0) dusts.push({x:W,y:Math.random()*H,r:Math.random()*2+1,dx:Math.random()*0.5+0.2,dy:Math.random()*0.2-0.1,a:Math.random()*0.5+0.2}); }
  function spawnEntities(){
    const diff = 1 + Math.floor(score/7)*0.1;
    const gi = Math.floor(Math.random()*imgs.gem.length);
    gems.push({img:imgs.gem[gi], x:W+50, y:50+Math.random()*(H-100), size:48});
    const count = 1 + Math.floor(diff);
    for (let i=0;i<count;i++){
      const oi = Math.floor(Math.random()*imgs.obs.length);
      obstacles.push({img:imgs.obs[oi], x:W+100+i*80, y:Math.random()*(H-60)+30, size:58});
    }
  }

  // ---------- Confetti ----------
  function initConfetti(){ confetti.length=0; for(let i=0;i<120;i++) confetti.push({x:W/2,y:H/2,dx:(Math.random()*4-2),dy:(Math.random()*-4-1),c:`hsl(${Math.random()*360},80%,60%)`}); }
  function updateConfetti(){ confetti.forEach(p=>{ p.x+=p.dx; p.y+=p.dy; p.dy+=0.05; }); }
  function drawConfetti(){ confetti.forEach(p=>{ ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,4,8); }); }

  // ---------- Input ----------
  function toGameXY(clientX,clientY){ const r=canvas.getBoundingClientRect(); return { x:(clientX-r.left)*(W/r.width), y:(clientY-r.top)*(H/r.height) }; }
  function flap(){ unlockAudio(); if(state===STATE.PLAY) labubu.yVel=JUMP; else if(state===STATE.OVER) startRun(); }
  canvas.addEventListener('mousedown', e => {
    unlockAudio();
    if (state === STATE.NAME) return; // handled by modal buttons
    if (state === STATE.OVER) { startRun(); return; }
    flap();
  });
  canvas.addEventListener('touchstart', e => { e.preventDefault(); const t=e.changedTouches[0]; canvas.dispatchEvent(new MouseEvent('mousedown',{clientX:t.clientX,clientY:t.clientY})); });
  document.addEventListener('keydown', e => {
    unlockAudio();
    if (state === STATE.NAME) {
      // Let the input handle keys
      return;
    }
    if (e.code === 'Space' || e.key === ' ' || e.key === 'ArrowUp') { e.preventDefault(); flap(); }
    if (e.key === 'r' || e.key === 'R') { if (state!==STATE.NAME) startRun(); }
  });

  // ---------- Run control ----------
  function startRun(){
    hideNameModal();
    state = STATE.PLAY;
    frame=0; score=0; won=false; newGlobalHigh=false;
    labubu.y=H/2; labubu.yVel=0;
    gems.length=0; obstacles.length=0; dusts.length=0; confetti.length=0;
  }
  function endRun(byCollision=true){
    state = STATE.OVER; won = score >= WIN_SCORE;
    if(currentName && score > (bestByName[currentName]||0)){ bestByName[currentName]=score; saveJSON(BEST_BY_NAME_KEY,bestByName); }
    if (byCollision) try{ sounds.gameover.currentTime=0; sounds.gameover.play(); }catch(e){}
    if(score > globalBest){
      globalBest = score; localStorage.setItem(GLOBAL_BEST_KEY, String(globalBest));
      newGlobalHigh = true; initConfetti();
      setTimeout(()=>{ try{ sounds.winner.currentTime=0; sounds.winner.play(); }catch(e){} },150);
    }
  }

  // ---------- Update / Draw ----------
  function update(){
    if(loaded < total) return;
    if(state === STATE.NAME){ return; }
    if(state === STATE.OVER){ if(newGlobalHigh) updateConfetti(); return; }

    frame++;

    labubu.yVel += GRAV;
    labubu.y += labubu.yVel;
    if(labubu.y - labubu.r < 0){ labubu.y = labubu.r; labubu.yVel = 0; }
    if(labubu.y + labubu.r > H){ labubu.y = H - labubu.r; labubu.yVel = 0; }

    const interval = Math.max(60, Math.round(100/(1 + Math.floor(score/7)*0.1)));
    if (frame % interval === 0) spawnEntities();
    spawnDust();

    for(let i=gems.length-1;i>=0;i--){
      const g=gems[i]; g.x -= SCROLL_SPEED;
      if (g.x + g.size < 0) gems.splice(i,1);
      else if (Math.hypot(g.x-labubu.x, g.y-labubu.y) < labubu.r + g.size/2){
        score++; gems.splice(i,1);
        try { sounds.collect.currentTime=0; sounds.collect.play(); } catch(e) {}
      }
    }
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i]; o.x -= SCROLL_SPEED;
      if (o.x + o.size < 0) obstacles.splice(i,1);
      else if (Math.hypot(o.x-labubu.x, o.y-labubu.y) < labubu.r + o.size/2){
        endRun(true);
      }
    }
    for(let i=dusts.length-1;i>=0;i--){
      const d=dusts[i]; d.x -= SCROLL_SPEED*0.5 + d.dx; d.y += d.dy;
      if (d.x < -d.r) dusts.splice(i,1);
    }
  }

  function draw(){
    ctx.fillStyle = bgGrad; ctx.fillRect(0,0,W,H);
    if(loaded < total){
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='24px sans-serif';
      ctx.fillText(`Loading ${loaded}/${total}`, W/2, H/2);
      return;
    }

    stars.forEach(layer=>layer.forEach(s=>{ s.update(); s.draw(); }));

    // scene
    dusts.forEach(d=>{ ctx.fillStyle=`rgba(200,200,200,${d.a})`; ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,2*Math.PI); ctx.fill(); });
    gems.forEach(g=> ctx.drawImage(g.img, g.x-g.size/2, g.y-g.size/2, g.size, g.size));
    obstacles.forEach(o=> ctx.drawImage(o.img, o.x-o.size/2, o.y-o.size/2, o.size, o.size));
    if(imgs.labubu) ctx.drawImage(imgs.labubu, labubu.x-labubu.r, labubu.y-labubu.r, labubu.r*2, labubu.r*2);

    // HUD
    if(state === STATE.PLAY){
      ctx.fillStyle='#fff'; ctx.textAlign='left'; ctx.font='16px sans-serif';
      if(currentName) ctx.fillText(`Player: ${currentName}`, 10, 22);
      ctx.fillText(`Gems: ${score}`, 10, 42);
      ctx.fillText(`High: ${globalBest}`, 10, 62);
    }

    if(state === STATE.OVER){
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      if(newGlobalHigh) drawConfetti();
      ctx.fillStyle='#fff'; ctx.textAlign='center';
      ctx.font='30px sans-serif';
      ctx.fillText(newGlobalHigh ? 'You set a new highscore!' : (won ? 'You Win!' : 'Game Over'), W/2, H/2 - 60);
      ctx.font='20px sans-serif';
      ctx.fillText(`Your Score: ${score}`, W/2, H/2 - 20);
      ctx.fillText(`High Score: ${globalBest}`, W/2, H/2 + 8);
      // Play again button (canvas)
      const bw=160,bh=44,bx=W/2-bw/2,by=H/2+30;
      ctx.fillStyle='#444'; ctx.fillRect(bx,by,bw,bh);
      ctx.strokeStyle='#777'; ctx.strokeRect(bx,by,bw,bh);
      ctx.fillStyle='#fff'; ctx.font='22px sans-serif';
      ctx.fillText('Play Again', W/2, by+30);
    }
  }

  function loop(){ update(); draw(); requestAnimationFrame(loop); }
  loop();

  // Start with modal so mobile keyboard can show
  showNameModal();
})();
</script>
</body>
</html>

